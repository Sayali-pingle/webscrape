        parser = LlamaParse(
            result_type="markdown",  # "markdown" and "text" are available
            api_key= os.getenv('LLAMA_CLOUD_API_KEY'),
            verbose= True
        )
        # filename_fn = lambda filename: {"file_name": filename}
        # print(filename_fn)
        # use SimpleDirectoryReader to parse our file
        file_paths= self.filestore.load_logs()
        print("list of docs before directory reader", file_paths)
        file_extractor = {".pdf": parser, ".txt":parser}
        reader = SimpleDirectoryReader('Marble_data_folder', file_extractor=file_extractor).load_data()
        # docu= reader.load_data()
        all_docs=[]
        print("printing type reader", type(reader))
        for docs in reader:
            # file_paths.append
            metadata= docs.metadata
            filepath= metadata.get('file_path')
            print("printing file path in the loop", filepath)
            self.filestore.log_query(filepath)
            print("docs getting printed")
            # for doc in docs:
            #     all_docs.append(doc)
        print("list of docs after directory reader", self.filestore.load_logs())

        vector_store = MilvusVectorStore(
                uri="./milvus_test_2.db", dim=1536, overwrite=True # text-embedding-ada-002 has dimension of 1536
                )
        pipeline = IngestionPipeline(
                transformations=[
                    SentenceSplitter(chunk_size=256, chunk_overlap=32),
                    TitleExtractor(),
                    Settings.embed_model,
                    ],
                    vector_store = vector_store
                    )
        # existing_ids= vector_store.list_ids()
        # for file in os.listdir('Marble_data'):
        #     if vector_store.get_entity_by_id('pdf_vectors', file):
        #         existing_ids.append(file)
        
        # print("list of exsisting ids", existing_ids)
        # run the pipeline
        # nodes = pipeline.run(documents=documents)
        pipeline.run(documents=reader)
        self.index = VectorStoreIndex.from_vector_store(vector_store=vector_store)
        print('self.index excuted successfully')
        # Store it for later
        # self.index.storage_context.persist(persist_dir=PERSIST_DIR)
        return self.index

#STREAMLIT

import streamlit as st
from streamlit_chat import message
from chat_func import Chatfunc

# Create an instance of the Chatfunc class
chatfunc = Chatfunc()

# Initialize session state
if 'messages' not in st.session_state:
    st.session_state.messages = []
if 'message_counter' not in st.session_state:
    st.session_state.message_counter = 0
if 'current_user_id' not in st.session_state:
    st.session_state.current_user_id = None

st.header("Chatbot")

# Display conversation history at the top
chat_container = st.container()

user_id = st.text_input("Type your user_id:")

# Check if user_id has changed
if user_id != st.session_state.current_user_id:
    st.session_state.messages = []
    st.session_state.message_counter = 0
    st.session_state.current_user_id = user_id

text_in = st.text_input("What's your question?")

if st.button("Send") and user_id:
    # Add user message to session state
    st.session_state.messages.append({
        "content": text_in, 
        "is_user": True, 
        "key": f"msg_{st.session_state.message_counter}"
    })
    st.session_state.message_counter += 1
    
    # Get the response from the Chatfunc class
    response = chatfunc.handle_query(user_id, text_in)
    
    # Add chatbot response to session state
    st.session_state.messages.append({
        "content": response, 
        "is_user": False, 
        "key": f"msg_{st.session_state.message_counter}"
    })
    st.session_state.message_counter += 1

# Display all messages in the chat container
with chat_container:
    for msg in st.session_state.messages:
        message(msg["content"], is_user=msg["is_user"], key=msg["key"])





################################

import streamlit as st
from streamlit_chat import message
from chat_func import Chatfunc

# Create an instance of the Chatfunc class
chatfunc = Chatfunc()

# Initialize session state
if 'messages' not in st.session_state:
    st.session_state.messages = []
if 'message_counter' not in st.session_state:
    st.session_state.message_counter = 0
if 'current_user_id' not in st.session_state:
    st.session_state.current_user_id = None
if 'feedback_given' not in st.session_state:
    st.session_state.feedback_given = False

# Custom CSS (same as before)
st.markdown("""
<style>
... (previous CSS remains the same)
.feedback-container {
    margin-top: 1rem;
    padding: 1rem;
    background-color: #1E1E1E;
    border-radius: 5px;
}
</style>
""", unsafe_allow_html=True)

# Fixed title at the top
st.markdown('<div class="title-container"><h1>Chatbot</h1></div>', unsafe_allow_html=True)

# Scrollable chat container
chat_container = st.container()
chat_container.markdown('<div class="chat-container">', unsafe_allow_html=True)

with chat_container:
    for msg in st.session_state.messages:
        message(msg["content"], is_user=msg["is_user"], key=msg["key"])
    
    # Display feedback widget after 3 chats
    if len(st.session_state.messages) >= 6 and not st.session_state.feedback_given:
        st.markdown('<div class="feedback-container">', unsafe_allow_html=True)
        st.write("How was your experience?")
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("üòÉ Good"):
                st.session_state.feedback_given = True
                st.success("Thank you for your feedback!")
        with col2:
            if st.button("üòê Neutral"):
                st.session_state.feedback_given = True
                st.success("Thank you for your feedback!")
        with col3:
            if st.button("üòü Poor"):
                st.session_state.feedback_given = True
                st.success("Thank you for your feedback!")
        st.markdown('</div>', unsafe_allow_html=True)

chat_container.markdown('</div>', unsafe_allow_html=True)

# Fixed input container at the bottom (same as before)
input_container = st.container()
input_container.markdown('<div class="input-container">', unsafe_allow_html=True)

with input_container:
    col1, col2, col3 = st.columns([1, 3, 1])
    with col1:
        user_id = st.text_input("User ID:", key="user_id")
    with col2:
        text_in = st.text_input("Your question:", key="question")
    with col3:
        send_button = st.button("Send")

    if send_button and user_id:
        # Check if user_id has changed
        if user_id != st.session_state.current_user_id:
            st.session_state.messages = []
            st.session_state.message_counter = 0
            st.session_state.current_user_id = user_id
            st.session_state.feedback_given = False

        # Add user message to session state
        st.session_state.messages.append({
            "content": text_in, 
            "is_user": True, 
            "key": f"msg_{st.session_state.message_counter}"
        })
        st.session_state.message_counter += 1
        
        # Get the response from the Chatfunc class
        response = chatfunc.handle_query(user_id, text_in)
        
        # Add chatbot response to session state
        st.session_state.messages.append({
            "content": response, 
            "is_user": False, 
            "key": f"msg_{st.session_state.message_counter}"
        })
        st.session_state.message_counter += 1
        
        # Rerun the app to update the chat
        st.experimental_rerun()

input_container.markdown('</div>', unsafe_allow_html=True)
